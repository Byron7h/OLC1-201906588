package analizadores;
import java_cup.runtime.Symbol;
import java.util.LinkedList;



parser code

  

{:

    public static String cache = "";
    String lista_iid = "";

    
    // listas que nos van a servir
    public static LinkedList<TError> errores = new LinkedList<TError>();
    

    // esta función nata de la herramienta, manda a llamar todos los errores sintacticos
    // necesita un objeto simbolo
   
    public void syntax_error(Symbol s)
    {        

        //obtenemos los valores de los parámetros del objeto s
        String lexema = s.value.toString();
        int fila = s.right;
        int columna = s.left;
      
        System.out.println("!!!!!!! Error Sintactico Recuperado !!!!!!!");
        System.out.println("\t\tLexema: "+lexema);
        System.out.println("\t\tFila: "+fila);
        System.out.println("\t\tColumna: "+columna);

        // error de tipo sintáctico
        //TError tmp = new TError("Sintactico",lexema,"Caracter no esperado",fila,columna);
        //errores.add(tmp);
        
    }


    //Metodo al que se llama en el momento en que ya no es posible una recuperacion de errores, se reporta y termina el análisis
    // en caso de que se pueda recurer este no saldrá
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception
    {        
        String lexema = s.value.toString();
        int fila = s.right;
        int columna = s.left;
        
        System.out.println("!!!!!!! Error Sintactico, Panic Mode !!!!!!! ");
        System.out.println("\t\tLexema: "+lexema);
        System.out.println("\t\tFila: "+fila);
        System.out.println("\t\tColumna: "+columna);
        
        //TError tmp = new TError("Sintactico",lexema, "Caracter no esperado",fila,columna);
        //errores.add(tmp);   
    }
:}







terminal suma;
terminal resta;
terminal mult;
terminal div;
terminal pot;
terminal mod;
terminal pare1;
terminal pare2;
terminal cor1;
terminal cor2;
terminal asignacion;
terminal pyc;
terminal coma;
terminal duda1;
terminal duda2;

terminal pr_verdadero;
terminal pr_falso;
terminal pr_ingresar;
terminal pr_como;
terminal pr_con_valor;
terminal pr_si;
terminal pr_entonces;
terminal pr_fin_si;
terminal pr_de_lo_contrario;
terminal pr_segun;
terminal pr_hacer;
terminal pr_fin_segun;
terminal pr_para;
terminal pr_hasta;
terminal pr_fin_para;
terminal pr_mientras;
terminal pr_fin_mientras;
terminal pr_repetir;
terminal pr_hasta_que;
terminal pr_retornar;
terminal pr_metodo;
terminal pr_fin_metodo;
terminal pr_con_parametros;
terminal pr_funcion;
terminal pr_fin_funcion;
terminal pr_ejecutar;
terminal pr_imprimir;
terminal pr_imprimir_nl;
terminal pr_or;
terminal pr_and;
terminal pr_not;
terminal pr_mayor;
terminal pr_menor;
terminal pr_mayor_o_igual;
terminal pr_menor_o_igual;
terminal pr_es_igual;
terminal pr_es_diferente;
terminal String pr_inicio;
terminal String pr_fin;
terminal pr_con_incremental;
terminal pr_o_si;


terminal td_cadena;
terminal td_numero;
terminal td_boolean;
terminal td_caracter;

terminal String num;
terminal String id;
terminal String cadena;
terminal String caracter;

non terminal String INSTRUCCION, ASIGNACION_;


non terminal INICIO, GLOBALES, GLOBAL, INSTRUCCIONES; 
non terminal DECLARACION, EXPRE, VALOR, TIPO, LISTA_ID, LISTA_PARAMETROS;
non terminal PRINT, RETORNO, EJECUCION, METODO, FUNCION, RAMIFICACION;
non terminal SEGUN, LISTA_SEGUN, MIENTRAS, REPETIR, SI, INSTRUCCION_R;
non terminal INSTRUCCIONES_R, PARA, GLO, PRIMERO;

precedence left pr_or;
precedence left pr_and;
precedence left pr_not;
precedence left pr_mayor, pr_menor, pr_mayor_o_igual, pr_menor_o_igual, pr_es_igual, pr_es_diferente;
precedence left suma, resta;
precedence left mult, div, mod;
precedence left pot;

start with INICIO;

INICIO  ::= PRIMERO;

PRIMERO ::= pr_inicio:a GLOBALES:b pr_fin:c   {:
                                                cache = a + c;
                                              :}
 ;  
GLOBALES ::=    GLOBALES GLO
                |GLO

;
GLO ::= GLOBAL
        |INSTRUCCION:a {:cache = cache  + a; :}
;

GLOBAL ::=   METODO 
           | FUNCION

;

INSTRUCCIONES ::=   INSTRUCCIONES INSTRUCCION 
                |   INSTRUCCION
;

INSTRUCCIONES_R ::=     INSTRUCCIONES_R INSTRUCCION_R 
                    |   INSTRUCCION_R
;

// instrucciones 
INSTRUCCION_R   ::= ASIGNACION_ pyc
                |   DECLARACION pyc
                |   PRINT pyc
                |   RETORNO pyc
                |   EJECUCION pyc
                |   SI
                |   SEGUN
                |   PARA 
                |   MIENTRAS
                |   REPETIR
                |   error
;

INSTRUCCION   ::=   ASIGNACION_:a pyc {:  RESULT = a ; :}
                |   DECLARACION pyc
                |   PRINT pyc
                |   EJECUCION pyc
                |   SI
                |   SEGUN
                |   PARA 
                |   MIENTRAS
                |   REPETIR
                |   error
;
                

DECLARACION   ::=   pr_ingresar LISTA_ID pr_como TIPO pr_con_valor EXPRE  
;

ASIGNACION_   ::=   LISTA_ID asignacion EXPRE:w {:  RESULT = lista_iid + " = " + w ;  
                                                lista_iid = ""; :}
;


EXPRE   ::=  pare1 EXPRE:a pare2 {:  RESULT=" ( " + a + " ) ";  :}

            |EXPRE:a suma EXPRE:b {:  RESULT=a + " + " + b;  :}
            |EXPRE:a resta EXPRE:b {:  RESULT=a + " - " + b;  :}
            |EXPRE:a mult EXPRE:b {:  RESULT=a + " * " + b;  :}
            |EXPRE:a div EXPRE:b {:  RESULT=a + " / " + b;  :}
            |EXPRE:a pot cor1 EXPRE:b cor2 {:  RESULT=a + " ** " + b;  :}
            |EXPRE:a mod EXPRE:b {:  RESULT=a + " % " + b;  :}

            |EXPRE:a pr_or EXPRE:b {:  RESULT=a + " or " + b;  :}
            |EXPRE:a pr_and EXPRE:b {:  RESULT=a + " and " + b;  :}
            |pr_not EXPRE:a {:  RESULT="not " + a;  :}

            |EXPRE:a  pr_mayor EXPRE:b {:  RESULT=a + " > " + b;  :}
            |EXPRE:a  pr_menor EXPRE:b {:  RESULT=a + " < " + b;  :}
            |EXPRE:a  pr_mayor_o_igual EXPRE:b {:  RESULT=a + " >= " + b;  :}
            |EXPRE:a  pr_menor_o_igual EXPRE:b {:  RESULT=a + " <= " + b;  :}
            |EXPRE:a  pr_es_igual EXPRE:b {:  RESULT=a + " == " + b;  :}
            |EXPRE:a  pr_es_diferente EXPRE:b {:  RESULT=a + " != " + b;  :}

            | VALOR:a {:  RESULT=a;  :}
;

VALOR ::=   num:a {:  RESULT=a;  :}
            | id:a {:  RESULT=a;  :}
            | cadena:a {:  RESULT=a;  :}
            | pr_verdadero:a {:  RESULT="true";  :}
            | pr_falso:a {:  RESULT="false";  :}
            | caracter:a {:  RESULT=a;  :}
;

TIPO ::=    td_cadena
            | td_numero
            | td_boolean
            | td_caracter   
;

LISTA_ID ::=  LISTA_ID coma:a id:b  {: lista_iid +=  a + " "+ b + lista_iid ;:}
            | id:a   {: lista_iid +=  a + lista_iid ;:} 
;

LISTA_PARAMETROS ::= LISTA_PARAMETROS coma EXPRE TIPO
            | EXPRE TIPO
            | pare1 LISTA_PARAMETROS pare2
;

PRINT ::=   pr_imprimir EXPRE
        |   pr_imprimir_nl EXPRE
;

RETORNO ::= pr_retornar EXPRE
;

EJECUCION ::= pr_ejecutar id pare1 pare2
            | pr_ejecutar id LISTA_PARAMETROS 
;

METODO ::=  pr_metodo id INSTRUCCIONES pr_fin_metodo
            | pr_metodo id pr_con_parametros LISTA_PARAMETROS INSTRUCCIONES pr_fin_metodo
;

FUNCION ::= pr_funcion id TIPO INSTRUCCIONES_R pr_fin_funcion
            | pr_funcion id TIPO pr_con_parametros LISTA_PARAMETROS INSTRUCCIONES_R pr_fin_funcion
;

SI ::=        pr_si EXPRE pr_entonces INSTRUCCIONES pr_fin_si
            | pr_si EXPRE pr_entonces INSTRUCCIONES pr_de_lo_contrario INSTRUCCIONES pr_fin_si
            | pr_si EXPRE pr_entonces INSTRUCCIONES RAMIFICACION pr_fin_si
            | pr_si EXPRE pr_entonces INSTRUCCIONES RAMIFICACION pr_de_lo_contrario INSTRUCCIONES pr_fin_si
;

RAMIFICACION ::= RAMIFICACION pr_o_si EXPRE pr_entonces INSTRUCCIONES
                |pr_o_si EXPRE pr_entonces INSTRUCCIONES
;

SEGUN ::=   pr_segun EXPRE pr_hacer LISTA_SEGUN pr_fin_segun
            | pr_segun EXPRE pr_hacer LISTA_SEGUN pr_de_lo_contrario pr_entonces INSTRUCCIONES pr_fin_segun
;

LISTA_SEGUN ::= LISTA_SEGUN duda1 EXPRE duda2 pr_entonces INSTRUCCIONES
            |   duda1 EXPRE duda2 pr_entonces INSTRUCCIONES
;

PARA ::=     pr_para EXPRE asignacion EXPRE pr_hasta EXPRE pr_hacer INSTRUCCIONES pr_fin_para
            |pr_para EXPRE asignacion EXPRE pr_hasta EXPRE pr_hacer  pr_fin_para
            |pr_para EXPRE asignacion EXPRE pr_hasta EXPRE pr_con_incremental EXPRE pr_hacer INSTRUCCIONES pr_fin_para
            |pr_para EXPRE asignacion EXPRE pr_hasta EXPRE pr_con_incremental EXPRE pr_hacer  pr_fin_para
;

MIENTRAS ::= pr_mientras EXPRE pr_hacer INSTRUCCIONES pr_fin_mientras
            |pr_mientras EXPRE pr_hacer pr_fin_mientras
;

REPETIR ::=  pr_repetir INSTRUCCIONES pr_hasta_que EXPRE
            |pr_repetir pr_hasta_que EXPRE
;


